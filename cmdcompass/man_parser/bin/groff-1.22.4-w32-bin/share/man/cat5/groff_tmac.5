GROFF_TMAC(5)                 File Formats Manual                GROFF_TMAC(5)



NNAAMMEE
       groff_tmac - macro files in the roff typesetting system

DDEESSCCRRIIPPTTIIOONN
       The  rrooffff(7) type-setting system provides a set of macro packages suit-
       able for special kinds of documents.  Each  macro  package  stores  its
       macros  and  definitions in a file called the package's ttmmaacc ffiillee.  The
       name is deduced from `TT_r_o_f_fMMAACC_r_o_s'.

       The tmac files are normal roff source documents, except that they  usu-
       ally  contain  only  definitions  and setup commands, but no text.  All
       tmac files are kept in a single or a small number of  directories,  the
       ttmmaacc directories.

GGRROOFFFF MMAACCRROO PPAACCKKAAGGEESS
       _g_r_o_f_f  provides  all classical macro packages, some more full packages,
       and some secondary packages for special purposes.  Note that it is  not
       possible  to use multiple primary macro packages at the same time; say-
       ing e.g.

              _s_h_# groff -m man -m ms foo

       or

              _s_h_# groff -m man foo -m ms bar

       fails.  Exception to this is the use of man pages written  with  either
       the  mmddoocc  or  the mmaann macro package.  See below the description of the
       _a_n_d_o_c_._t_m_a_c file.

   MMaann PPaaggeess
       _m_a_n    This is the  classical  macro  package  for  Unix  manual  pages
              (man   pages);   it   is  quite  handy  and  easy  to  use;  see
              ggrrooffff__mmaann(7).

       _d_o_c
       _m_d_o_c   An alternative macro package for man pages mainly  used  in  BSD
              systems;  it provides many new features, but it is not the stan-
              dard for man pages; see ggrrooffff__mmddoocc(7).

       _a_n_d_o_c
       _m_a_n_d_o_c Use this file in case you don't know whether the mmaann  macros  or
              the  mmddoocc package should be used.  Multiple man pages (in either
              format) can be handled.

   FFuullll PPaacckkaaggeess
       The packages in this section provide a complete set of macros for writ-
       ing  documents  of  any  kind,  up to whole books.  They are similar in
       functionality; it is a matter of taste which one to use.

       _m_e     The classical _m_e macro package; see ggrrooffff__mmee(7).

       _m_m     The semi-classical _m_m macro package; see ggrrooffff__mmmm(7).

       _m_o_m    The new _m_o_m macro package, only available in groff.  As this  is
              not  based  on other packages, it can be freely designed.  So it
              is expected to become quite a nice, modern macro  package.   See
              ggrrooffff__mmoomm(7).

       _m_s     The classical _m_s macro package; see ggrrooffff__mmss(7).

   LLaanngguuaaggee--ssppeecciiffiicc PPaacckkaaggeess
       _c_s     This  file  adds  support  for Czech localization, including the
              main macro packages (me, mom, mm, and ms).

              Note that _c_s_._t_m_a_c sets the input encoding to latin-2.

       _d_e
       _d_e_n    German localization support, including the main  macro  packages
              (me, mom, mm, and ms).

              _d_e_._t_m_a_c  selects  hyphenation patterns for traditional orthogra-
              phy, and _d_e_n_._t_m_a_c does the same for the new orthography (`Recht-
              schreibreform').  It should be used as the last macro package on
              the command line.

       _f_r     This file adds support for French  localization,  including  the
              main macro packages (me, mom, mm, and ms).  Example:

                     _s_h_# groff -ms -mfr foo.ms > foo.ps

              Note  that  _f_r_._t_m_a_c  sets  the  input encoding to latin-9 to get
              proper support of the `oe' ligature.

       _s_v     Swedish localization support, including  the  me,  mom,  and  ms
              macro  packages.  Note that Swedish for the mm macros is handled
              separately; see ggrrooffff__mmmmssee(7).  It should be used  as  the  last
              macro package on the command line.

   IInnppuutt EEnnccooddiinnggss
       _l_a_t_i_n_1
       _l_a_t_i_n_2
       _l_a_t_i_n_5
       _l_a_t_i_n_9 Various  input encodings supported directly by groff.  Normally,
              this macro is loaded at the very  beginning  of  a  document  or
              specified as the first macro argument on the command line.  rrooffff
              loads latin1 by default at  start-up.   Note  that  these  macro
              packages don't work on EBCDIC hosts.

       _c_p_1_0_4_7 Encoding  support  for  EBCDIC.  On those platforms it is loaded
              automatically at start-up.  Due to  different  character  ranges
              used in rrooffff it doesn't work on architectures which are based on
              ASCII.

       Note that it can happen that some input  encoding  characters  are  not
       available for a particular output device.  For example, saying

       groff -Tlatin1 -mlatin9 ...

       fails  if you use the Euro character in the input.  Usually, this limi-
       tation is present only for devices which have a limited set  of  output
       glyphs  (--TTaasscciiii, --TTllaattiinn11); for other devices it is usually sufficient
       to install proper fonts which contain the necessary glyphs.

   SSppeecciiaall PPaacckkaaggeess
       The macro packages in this section are  not  intended  for  stand-alone
       usage,  but can be used to add special functionality to any other macro
       package or to plain groff.

       _6_2_b_i_t  Provides macros for addition, multiplication,  and  division  of
              62-bit  integers  (allowing  safe multiplication of 31-bit inte-
              gers, for example).

       _e_c     Switch to the  EC  and  TC  font  families.   To  be  used  with
              ggrrooddvvii(1)  - this man page also gives more details of how to use
              it.

       _h_d_t_b_l  The Heidelberger table macros, contributed by Joachim Walsdorff,
              allow  the  generation of tables through a syntax similar to the
              HTML table model.  Note that _h_d_t_b_l is a  macro  package,  not  a
              preprocessor  like  ttbbll(1).   _h_d_t_b_l works only with the --TTppss and
              --TTppddff output devices.  See ggrrooffff__hhddttbbll(7)..

       _p_a_p_e_r_s_i_z_e
              This macro file is already loaded at start-up  by  ttrrooffff  so  it
              isn't necessary to call it explicitly.  It provides an interface
              to set the paper size  on  the  command  line  with  the  option
              --ddppaappeerr==_s_i_z_e.  Possible values for _s_i_z_e are the same as the pre-
              defined ppaappeerrssiizzee values in the DESC file (only  lowercase;  see
              ggrrooffff__ffoonntt(5) for more) except aa77-dd77.  An appended ll (ell) char-
              acter denotes landscape orientation.  Examples:  aa44,  cc33ll,  lleett--
              tteerrll.

              Most output drivers need additional command-line switches --pp and
              --ll to override the default paper length and orientation  as  set
              in  the driver-specific DESC file.  For example, use the follow-
              ing for PS output on A4 paper in landscape orientation:

              _s_h_# groff -Tps -dpaper=a4l -P-pa4 -P-l -ms foo.ms > foo.ps

       _p_d_f_p_i_c A single macro is provided in this file, PPSSPPIICC, to include a PDF
              graphic in a document, i.e., under the output device --TTppddff.  For
              all other devices, _p_s_p_i_c is used.  So _p_d_f_p_i_c is an extension  of
              _p_s_p_i_c.   By  that  you can now even replace all PPSSPPIICC by PPDDFFPPIICC,
              nothing gets lost by that.  The options of PPDDFFPPIICC are  identical
              to the PPSSDDIIFF options.

       _p_i_c    This  file provides proper definitions for the macros PPSS and PPEE,
              needed for the ppiicc(1) preprocessor.  They center  each  picture.
              Use it only if your macro package doesn't provide proper defini-
              tions for those two macros (actually, most of them already do).

       _p_s_p_i_c  A single macro is provided in this file,  PPSSPPIICC,  to  include  a
              PostScript  graphic in a document.  The following output devices
              support  inclusion  of  PS  images:  --TTppss,  --TTddvvii,  --TThhttmmll,  and
              --TTxxhhttmmll; for all other devices the image is replaced with a hol-
              low rectangle of the same size.   This  macro  file  is  already
              loaded  at  start-up  by  ttrrooffff so it isn't necessary to call it
              explicitly.

              Syntax:

                     ..PPSSPPIICC [--LL|--RR|--CC|--II _n] _f_i_l_e [_w_i_d_t_h [_h_e_i_g_h_t]]

              _f_i_l_e is the name of the PostScript file; _w_i_d_t_h and  _h_e_i_g_h_t  give
              the  desired  width and height of the image.  If neither a _w_i_d_t_h
              nor a _h_e_i_g_h_t argument is specified, the  image's  natural  width
              (as given in the file's bounding box) or the current line length
              is used as the width, whatever is smaller.  The _w_i_d_t_h and _h_e_i_g_h_t
              arguments  may  have  scaling  indicators  attached; the default
              scaling indicator is ii.  This macro scales the graphic uniformly
              in  the x and y directions so that it is no more than _w_i_d_t_h wide
              and _h_e_i_g_h_t high.  Option --CC centers  the  graphic  horizontally,
              which  is  the default.  The --LL and --RR options cause the graphic
              to be left-aligned  and  right-aligned,  respectively.   The  --II
              option  causes  the graphic to be indented by _n (default scaling
              indicator is mm).

              For use of ..PPSSPPIICC within a diversion it is recommended to extend
              it  with the following code, assuring that the diversion's width
              completely covers the image's width.

                     .am PSPIC
                     .  vpt 0
                     \h'(\\n[ps-offset]u + \\n[ps-deswid]u)'
                     .  sp -1
                     .  vpt 1
                     ..

       _p_t_x    A single macro is provided in this file, xxxx, for formatting per-
              muted  index  entries as produced by the GNU ppttxx(1) program.  In
              case you need a different formatting, copy the macro  into  your
              document and adapt it to your needs.

       _t_r_a_c_e  Use  this for tracing macro calls.  It is only useful for debug-
              ging.  See ggrrooffff__ttrraaccee(7)..

       _t_t_y_-_c_h_a_r
              Overrides the definition of standard troff characters  and  some
              groff  characters  for  TTY  devices.  The optical appearance is
              intentionally inferior compared to that of normal TTY formatting
              to allow processing with critical equipment.

       _w_w_w    Additions of elements known from the HTML format, as used in the
              internet (World Wide Web) pages; this  includes  URL  links  and
              mail addresses; see ggrrooffff__wwwwww(7).

NNAAMMIINNGG
       Classical roff systems were designed before the conventions of the mod-
       ern C ggeettoopptt(3) call evolved, and used a naming scheme for macro  pack-
       ages  that  looks  odd  to  modern  eyes.   Macro  packages were always
       included with the option --mm; when this option was directly followed  by
       its  argument  without  an  intervening  space, this looked like a long
       option preceded by a single minus -- a sensation in the computer  stone
       age.  To make this invocation form work, classical troff macro packages
       used names that started with the letter `m', which was omitted  in  the
       naming of the macro file.

       For  example, the macro package for the man pages was called _m_a_n, while
       its macro file _t_m_a_c_._a_n.  So it could be activated by the argument _a_n to
       option --mm, or --mmaann for short.

       For  similar reasons, macro packages that did not start with an `m' had
       a leading `m' added in the documentation and in  speech;  for  example,
       the package corresponding to _t_m_a_c_._d_o_c was called _m_d_o_c in the documenta-
       tion, although a more suitable name would be _d_o_c.  For,  when  omitting
       the  space between the option and its argument, the command-line option
       for activating this package reads --mmddoocc.

       To cope with all situations, actual  versions  of  ggrrooffff(1)  are  smart
       about  both  naming  schemes  by  providing  two  macro  files  for the
       inflicted macro packages; one with a leading `m' the other one  without
       it.   So in _g_r_o_f_f, the _m_a_n macro package may be specified as one of the
       following four methods:

              _s_h_# groff -m man
              _s_h_# groff -man
              _s_h_# groff -mman
              _s_h_# groff -m an

       Recent packages that do not start with `m' do not use an additional `m'
       in the documentation.  For example, the _w_w_w macro package may be speci-
       fied only as one of the two methods:

              _s_h_# groff -m www
              _s_h_# groff -mwww

       Obviously, variants like _-_m_m_w_w_w would not make much sense.

       A second strange feature of classical troff was to name macro files  in
       the form _t_m_a_c_.name.  In modern operating systems, the type of a file is
       specified as a postfix, the file name extension.   Again,  groff  copes
       with  this  situation by searching both _a_n_y_t_h_i_n_g..ttmmaacc and ttmmaacc.._a_n_y_t_h_i_n_g
       if only _a_n_y_t_h_i_n_g is specified.

       The easiest way to find out which macro packages  are  available  on  a
       system  is  to check the man page ggrrooffff(1), or the contents of the _t_m_a_c
       directories.

       In _g_r_o_f_f, most  macro  packages  are  described  in  man  pages  called
       ggrrooffff___n_a_m_e(7), with a leading `m' for the classical packages.

IINNCCLLUUSSIIOONN
       There are several ways to use a macro package in a document.  The clas-
       sical way is to specify the troff/groff option  --mm  _n_a_m_e  at  run-time;
       this makes the contents of the macro package _n_a_m_e available.  In groff,
       the file name_._t_m_a_c is searched within the  tmac  path;  if  not  found,
       _t_m_a_c_.name is searched for instead.

       Alternatively,  it  is  also possible to include a macro file by adding
       the request ..ssoo _f_i_l_e_n_a_m_e into the document; the argument  must  be  the
       full  file  name of an existing file, possibly with the directory where
       it is kept.  In groff, this was improved by the  similar  request  ..mmssoo
       _p_a_c_k_a_g_e,  which  added  searching in the tmac path, just like option --mm
       does.

       Note that in order to resolve the ..ssoo and ..mmssoo requests, the roff  pre-
       processor  ssooeelliimm(1)  must  be  called if the files to be included need
       preprocessing.  This can be done either directly by a pipeline  on  the
       command  line  or by using the troff/groff option --ss.  _m_a_n calls soelim
       automatically.

       For example, suppose a macro file is stored as

              _d_:_/_u_s_r_/_s_h_a_r_e_/_g_r_o_f_f_/_1_._2_2_._4_/_t_m_a_c_/_m_a_c_r_o_s_._t_m_a_c

       and is used in some document called _d_o_c_u_._r_o_f_f.

       At run-time, the formatter call for this is

              _s_h_# groff -m macros docu.roff

       To include the macro file directly in the document either

              .mso macros.tmac

       is used or

              .so d:/usr/share/groff/1.22.4/tmac/macros.tmac

       In both cases, the formatter should be called with option --ss to  invoke
       ssooeelliimm.

              _s_h_# groff -s docu.roff

       If  you  want to write your own groff macro file, call it whatever_._t_m_a_c
       and put it in a directory in the tmac path; see section "Files"  below.
       Then documents can include it with the ..mmssoo request or the option --mm.

WWRRIITTIINNGG MMAACCRROOSS
       A  rrooffff(7)  document is a text file that is enriched by predefined for-
       matting  constructs,  such  as  requests,  escape  sequences,  strings,
       numeric registers, and macros from a macro package.  These elements are
       described in rrooffff(7).

       To give a document a personal style, it is most useful  to  extend  the
       existing elements by defining some macros for repeating tasks; the best
       place for this is near the beginning of the document or in  a  separate
       file.

       Macros  without arguments are just like strings.  But the full power of
       macros reveals when arguments are passed with a macro call.  Within the
       macro  definition,  the arguments are available as the escape sequences
       \\$$11, ..., \\$$99, \\$$[[...]], \\$$**, and \\$$@@, the name under  which  the  macro
       was  called  is  in  \\$$00,  and  the  number of arguments is in register
       \\nn[[..$$]]; see ggrrooffff(7).

   CCooppyy--iinn MMooddee
       The phase when groff reads a macro is called _c_o_p_y_-_i_n _m_o_d_e or _c_o_p_y  _m_o_d_e
       in  roff-talk.   This is comparable to the C preprocessing phase during
       the development of a program written in the C language.

       In this phase, groff interprets all backslashes; that  means  that  all
       escape  sequences  in  the  macro  body are interpreted and replaced by
       their value.  For constant expressions, this is wanted, but strings and
       registers  that  might  change  between calls of the macro must be pro-
       tected from being evaluated.  This is most easily done by doubling  the
       backslash  that  introduces the escape sequence.  This doubling is most
       important for the positional parameters.  For example, to print  infor-
       mation  on the arguments that were passed to the macro to the terminal,
       define a macro named `.print_args', say.

              .ds midpart was called with
              .de print_args
              .  tm \f[I]\\$0\f[] \*[midpart] \\n[.$] arguments:
              .  tm \\$*
              ..

       When calling this macro by

              .print_args arg1 arg2

       the following text is printed to the terminal:

              _p_r_i_n_t___a_r_g_s was called with the following 2 arguments:
              arg1 arg2

       Let's analyze each backslash in the macro  definition.   As  the  posi-
       tional  parameters and the number of arguments change with each call of
       the macro their leading backslash must be  doubled,  which  results  in
       \\_$_*  and  \\_[_._$_].  The same applies to the macro name because it could
       be called with an alias name, so \\_$_0.

       On the other hand, _m_i_d_p_a_r_t is a constant string, it does not change, so
       no  doubling  for  \_*_[_m_i_d_p_a_r_t_].  The \_f escape sequences are predefined
       groff elements for setting the font within the text.  Of  course,  this
       behavior does not change, so no doubling with \_f_[_I_] and \_f_[_].

   DDrraafftt MMooddee
       Writing groff macros is easy when the escaping mechanism is temporarily
       disabled.  In groff, this is done by enclosing the macro  definition(s)
       into  a pair of ..eeoo and ..eecc requests.  Then the body in the macro defi-
       nition is just like a normal part of the document -- text  enhanced  by
       calls  of  requests, macros, strings, registers, etc.  For example, the
       code above can be written in a simpler way by

              .eo
              .ds midpart was called with
              .de print_args
              .  tm \f[I]\$0\f[] \*[midpart] \n[.$] arguments:
              .  tm \$*
              ..
              .ec

       Unfortunately, draft mode cannot be used universally.  Although  it  is
       good  enough for defining normal macros, draft mode fails with advanced
       applications, such as indirectly defined strings, registers,  etc.   An
       optimal  way is to define and test all macros in draft mode and then do
       the backslash doubling as a final step; do not forget to remove the _._e_o
       request.

   TTiippss ffoorr MMaaccrroo DDeeffiinniittiioonnss
       +o      Start  every  line  with  a dot, for example, by using the groff
              request ..nnoopp for text lines, or write your own macro  that  han-
              dles also text lines with a leading dot.

                     .de Text
                     .  if (\\n[.$] == 0) \
                     .    return
                     .  nop \)\\$*\)
                     ..

       +o      Write  a  comment  macro  that  works both for copy-in and draft
              mode; for as escaping is off in draft mode, trouble might  occur
              when normal comments are used.  For example, the following macro
              just ignores its arguments, so it acts like a comment line:

                     .de c
                     ..
                     .c This is like a comment line.

       +o      In long macro definitions, make ample use of  comment  lines  or
              almost-empty  lines (this is, lines which have a leading dot and
              nothing else) for a better structuring.

       +o      To increase readability, use groff's  indentation  facility  for
              requests and macro calls (arbitrary whitespace after the leading
              dot).

   DDiivveerrssiioonnss
       Diversions can be used to implement  quite  advanced  programming  con-
       structs.   They  are comparable to pointers to large data structures in
       the C programming language, but their usage is quite different.

       In their simplest form, diversions are multi-line strings, but they get
       their  power  when  diversions are used dynamically within macros.  The
       (formatted) information stored in a diversion can be retrieved by call-
       ing the diversion just like a macro.

       Most  of  the  problems  arising  with diversions can be avoided if you
       remain aware of the fact that diversions always store  complete  lines.
       If  diversions  are  used  when  the  line buffer has not been flushed,
       strange results are produced; not knowing this, many people get desper-
       ate  about  diversions.   To ensure that a diversion works, line breaks
       should be added at the right places.  To be on the secure side, enclose
       everything  that  has to do with diversions into a pair of line breaks;
       for example, by explicitly using ..bbrr requests.   This  rule  should  be
       applied  to  diversion  definition, both inside and outside, and to all
       calls of diversions.  This is a bit of overkill, but it works nicely.

       [If you really need diversions which should ignore the current  partial
       line,  use environments to save the current partial line and/or use the
       ..bbooxx request.]

       The most powerful feature using diversions  is  to  start  a  diversion
       within a macro definition and end it within another macro.  Then every-
       thing between each call of this macro pair is stored within the  diver-
       sion and can be manipulated from within the macros.

FFIILLEESS
       All  macro  package files must be named name_._t_m_a_c to fully use the tmac
       mechanism.  _t_m_a_c_.name as with classical packages is possible  as  well,
       but deprecated.

       The  macro  files  are  kept in the _t_m_a_c _d_i_r_e_c_t_o_r_i_e_s; a colon separated
       list of these constitutes the _t_m_a_c _p_a_t_h.

       The search sequence for macro files is (in that order):

       +o      the directories specified  with  troff/groff's  --MM  command-line
              option

       +o      the  directories  given in the _G_R_O_F_F___T_M_A_C___P_A_T_H environment vari-
              able

       +o      the current directory (only if in unsafe mode, which is  enabled
              by the --UU command-line switch)

       +o      the home directory

       +o      a platform-specific directory, being

                     _d_:_/_u_s_r_/_l_i_b_/_g_r_o_f_f_/_s_i_t_e_-_t_m_a_c

              in this installation

       +o      a site-specific (platform-independent) directory, being

                     _d_:_/_u_s_r_/_s_h_a_r_e_/_g_r_o_f_f_/_s_i_t_e_-_t_m_a_c

              in this installation

       +o      the main tmac directory, being

                     _d_:_/_u_s_r_/_s_h_a_r_e_/_g_r_o_f_f_/_1_._2_2_._4_/_t_m_a_c

              in this installation

EENNVVIIRROONNMMEENNTT
       _G_R_O_F_F___T_M_A_C___P_A_T_H
              A  colon  separated list of additional tmac directories in which
              to search for macro files.   See  the  previous  section  for  a
              detailed description.

AAUUTTHHOORRSS
       This  document  was  written  by  Bernd  Warken <groff-bernd.warken-72@
       web.de> and Werner Lemberg <wl@gnu.org>.

SSEEEE AALLSSOO
       _G_r_o_f_f_: _T_h_e _G_N_U _I_m_p_l_e_m_e_n_t_a_t_i_o_n _o_f _t_r_o_f_f, by Trent A. Fisher  and  Werner
       Lemberg,  is the primary _g_r_o_f_f manual.  You can browse it interactively
       with "info groff".

       ggrrooffff(1)
              an overview of the groff system.

       ggrrooffff__mmaann(7),
       ggrrooffff__mmddoocc(7),
       ggrrooffff__mmee(7),
       ggrrooffff__mmmm(7),
       ggrrooffff__mmoomm(7),
       ggrrooffff__mmss(7),
       ggrrooffff__ttrraaccee(7),
       ggrrooffff__wwwwww(7).
              the groff tmac macro packages.

       ggrrooffff(7)
              the groff language.

       The Filesystem Hierarchy Standard is available  at  the  FHS  web  site
       <http://www.pathname.com/fhs/>.



groff 1.22.4                     December 2018                   GROFF_TMAC(5)
